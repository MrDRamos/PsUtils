# Cleanup
Get-EventSubscriber | ForEach-Object { Unregister-Event -SourceIdentifier $_.SourceIdentifier }
Get-Job | Stop-Job
Get-Job | Remove-Job
Get-Event | Remove-Event


<#
.SYNOPSIS
    Demonstrates a mechanism to monitor the termination of processes running on a host.
    We register event handlers with a WMI event engine that:
        - Write output to the console
        - Raise a WaitHandle to that the main process logic can test for
    A simple application could just do all it work in the Action scriptblock.
    A more realistic application will run this function in a background thread,
    and then wait/test for the signaled event at the appropriate point in the program flow.

.NOTES
    Register-CimIndicationEvent
    https://learn.microsoft.com/en-us/powershell/module/cimcmdlets/register-cimindicationevent?view=powershell-5.1

    __InstanceDeletionEvent class
    https://learn.microsoft.com/en-us/windows/win32/wmisdk/--instancedeletionevent

    win32-processstoptrace
    https://learn.microsoft.com/en-us/previous-versions/windows/desktop/krnlprov/win32-processstoptrace?redirectedfrom=MSDN
#>
function Enable-ProcessStoppedEvents
{
    [CmdLetBinding()]            
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrWhiteSpace()]
        [string] $ProcessName, # We match all full process names that start 'like' this. e.g. Notepad matches Notepad.exe or Notepad++.exe

        [Parameter()]
        [Object] $EventWaitHandle = $null,

        [Parameter()]
        [int] $MaxEvents = -1
    )

    # Note: The $EventWaitHandle argument does not persist after exiting this call, and therefore can't be used in the Action [scriptblock] 
    # The Action [scriptblock] will need a global variable. So here we create a global(private) variable reference to $EventWaitHandle
    if ($EventWaitHandle)
    {
        $Global:G_EventWaitHandle = $EventWaitHandle
    }

    if ([string]::IsNullOrWhitespace($ProcessName))
    {
        [scriptblock]$ActionBlock = {
            <# Automatic PowerShell variables within a registered Action Script-Block:
            $Sender     = The object (Timer,Watcher...) that generated the event 
            $EventArgs  = The data associated with the event, generated by the Sender
            $Event      {
                ComputerName
                RunspaceId      = Unique [int]
                EventIdentifier = Unique [int]
                Sender          = $Sender
                SourceEventArgs = $EventArgs
                SourceArgs[]    = @(Sender, $EventArgs)
                SourceIdentifier= Unique name for the event e.g: "SenderName.EventName"
                TimeGenerated   = [DateTime]
                MessageData     = Optional data associated with New-Event -or
                                Optional data associated with event subscription
            }
            #>
            $Global:DbgEvent = $Event

            if ($G_EventWaitHandle)
            {
                $G_EventWaitHandle.Set()
            }
            $e = $Event.SourceEventArgs.NewEvent
            Write-Host ("{0} Pid:{1} ExitCode:{2} stopped at: {3}" -f $e.ProcessName, $e.ProcessID, $e.ExitStatus, $Event.TimeGenerated)
        }
        Register-CimIndicationEvent -ClassName Win32_ProcessStopTrace -SourceIdentifier 'ProcessStopTrace' `
                                    -MaxTriggerCount $MaxEvents -Action $ActionBlock | Out-Null
    }
    else 
    {
        $Query = "Select * From __InstanceDeletionEvent within 1 Where TargetInstance ISA 'Win32_Process' and TargetInstance.name like '$ProcessName%'"
        Register-CimIndicationEvent -Query $Query -SourceIdentifier 'ProcessStopTrace' -MaxTriggerCount $MaxEvents  -Action {
            $Global:DbgEvent = $Event
            if ($G_EventWaitHandle)
            {
                $G_EventWaitHandle.Set()
            }
            $e = $Event.SourceEventArgs.NewEvent.TargetInstance
            Write-Host ("{0} Pid: {1} stopped at {2}" -f $e.Name, $e.ProcessID, $Event.TimeGenerated)
        }  | Out-Null
    }
}

$ProcessName = 'Notepad'  # Notepad will match: Notepad.exe or Notepad++.exe
$ProcessExitedEvent = New-Object System.Threading.AutoResetEvent -ArgumentList $false #Aet the initial state to non-signaled
Enable-ProcessStoppedEvents -ProcessName $ProcessName -EventWaitHandle $ProcessExitedEvent

Write-Host "Stop a running Notepad or Notepad++ process to generate a termination event"
# Note: No out is observed during call to ReadKey because this thread will blocking the Event-Actions
Write-Host "The events-handler output will show, once you press any key... " -NoNewline
[void][System.Console]::ReadKey($true)
Write-Host                  # Yield to other background tasks that have been queued for execution on this thread
#Start-Sleep -Seconds 0     # Yield to other background tasks that have been queued for execution on this thread

[int]$index = [System.Threading.WaitHandle]::WaitAny($ProcessExitedEvent, 0)#, $true) 
if ($index -eq 0)
{
    Write-Host "The ProcessExitedEvent event was raised" -ForegroundColor Green
    Write-Host "The last event was for: $($Global:DbgEvent.SourceEventArgs.NewEvent.TargetInstance.Name)"
}
elseif ($index -eq [System.Threading.WaitHandle]::WaitTimeout)
{
    Write-Host "Timeout waiting for: ProcessExitedEvent event" -ForegroundColor Yellow
}

# Get-EventSubscriber | Format-Table
@"

The registered events-handler is still active.
Start and stop additional Notepad or Notepad++ instances to show realtime activation of the events-handler.

To stop the events-handler run:  
Get-Job | Stop-Job

"@ | Write-Host

