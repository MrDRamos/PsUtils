# Cleanup
Get-EventSubscriber | ForEach-Object { Unregister-Event -SourceIdentifier $_.SourceIdentifier }
Get-Job | Stop-Job
Get-Job | Remove-Job
Get-Event | Remove-Event


<#
    System.IO.FileSystemWatcher
    https://learn.microsoft.com/en-us/dotnet/api/system.io.filesystemwatcher?view=netframework-4.8.1

    PowerShell and Events: Object Events
    https://learn-powershell.net/2013/02/08/powershell-and-events-object-events/
#>
function Watch-Folder
{
    [CmdLetBinding()]            
    param(
        [Parameter(Mandatory)]
        [ValidateNotNullOrWhiteSpace()]
        [string] $Path
    )

    $fileWatcher = New-Object System.IO.FileSystemWatcher
    $fileWatcher.Path = $Path
    $fileWatcher.IncludeSubdirectories = $true
    Register-ObjectEvent -InputObject $fileWatcher -EventName Changed -SourceIdentifier File.Changed -Action {
        <# Automatic PowerShell variables within a registered Action Script-Block:
        $Sender     = The object (Timer,Watcher...) that generated the event 
        $EventArgs  = The data associated with the event, generated by the Sender
        $Event      {
            ComputerName
            RunspaceId      = Unique [int]
            EventIdentifier = Unique [int]
            Sender          = $Sender
            SourceEventArgs = $EventArgs
            SourceArgs[]    = @(Sender, $EventArgs)
            SourceIdentifier= Unique name for the event e.g: "SenderName.EventName"
            TimeGenerated   = [DateTime]
            MessageData     = Optional data associated with New-Event -or
                              Optional data associated with event subscription
        }
        #>
        $Global:DbgEvent = $event
        Write-Host ("File Changed: {0} on {1}" -f $event.SourceEventArgs.Name, (Split-Path $event.SourceEventArgs.FullPath))
        if ($WatchProcExitedSignal)
        {
            $WatchProcExitedSignal.Set()
        }
    } | Out-Null
    
    Register-ObjectEvent -InputObject $fileWatcher -EventName Created -SourceIdentifier File.Created -Action {
        $Global:DbgEvent = $event
        Write-Host ("File Created: {0} on {1}" -f $event.SourceEventArgs.Name, (Split-Path $event.SourceEventArgs.FullPath))
        if ($WatchProcExitedSignal)
        {
            $WatchProcExitedSignal.Set()
        }
    } | Out-Null
    
    Register-ObjectEvent -InputObject $fileWatcher -EventName Deleted -SourceIdentifier File.Deleted -Action {
        $Global:DbgEvent = $event
        Write-Host ("File Deleted: {0} on {1}" -f $event.SourceEventArgs.Name, (Split-Path $event.SourceEventArgs.FullPath))
        if ($WatchProcExitedSignal)
        {
            $WatchProcExitedSignal.Set()
        }
    } | Out-Null
    
    Register-ObjectEvent -InputObject $fileWatcher -EventName Error -SourceIdentifier File.Error -Action {
        $Global:DbgEvent = $event
        Write-Host "The FileSystemWatcher has detected an error $($event.SourceEventArgs.GetException().Message)"
    } | Out-Null
}
    
$WatchProcExitedSignal = New-Object System.Threading.AutoResetEvent -ArgumentList $false #Set the initial state to non-signaled
$Path = 'C:\temp'
Watch-Folder -Path $Path

Write-Host "To generate FileSystemWatcher events: In another console Create, Edit or Delete files in: $Path"
# Note: No out is observed during call to ReadKey because this thread will blocking the Event-Actions
Write-Host "The output events will show, once you press any key in this console... " -NoNewline
[void][System.Console]::ReadKey($true)
Write-Host                  # Yield to other background tasks that have been queued for execution on this thread
#Start-Sleep -Seconds 0     # Yield to other background tasks that have been queued for execution on this thread

[int]$index = [System.Threading.WaitHandle]::WaitAny($WatchProcExitedSignal, 0)#, $true) 
if ($index -eq 0)
{
    Write-Host "The WatchProcExitedSignal event was raised" -ForegroundColor Yellow
    Write-Host "The last event was for: $($Global:DbgEvent.SourceArgs.FullPath)"
}
elseif ($index -eq [System.Threading.WaitHandle]::WaitTimeout)
{
    Write-Host "Timeout waiting for: WatchProcExitedSignal event" -ForegroundColor Yellow
}

# Get-EventSubscriber | Format-Table
@"

The registered FileSystemWatcher events are still active.
Create, Edit or Delete more files in: $Path
to show the realtime output of additional FileSystemWatcher events.

To stop the events run:  
Get-Job | Stop-Job

"@ | Write-Host
