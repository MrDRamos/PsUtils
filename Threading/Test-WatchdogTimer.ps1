[CmdletBinding()]
param (
    [Parameter()]
    [int]$IntervalMiliSec = 500,

    [Parameter()]
    [int]$WatchDogSec = 3,

    [Parameter()]
    [int]$TotalSec = 10
)

#Region PsEvent
##################### Powrshell Event Hanlder #####################
<#
Powershell Event Registration
https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.utility/register-objectevent?view=powershell-7.2


# System.Timers.Timer Class: 
https://docs.microsoft.com/en-us/dotnet/api/system.timers.timer?view=net-6.0
#>

[int] $EventCount = 0 #Script scope variable
$Script:G_Str = "hello world"
[int] $G_Int = 22 
$WatchDogTimerEventId = 'WatchDogTimer.Elapsed'

# This demo has several mechanisms for the WatchDog event handler to signal back to the main loop when its done
$WatchDogDoneEventId = $WatchDogDoneSignal = $WatchDogDoneFlag = 0
# Uncomment one of the variable initializes below to activate that mechanism:
$WatchDogDoneEventId = "Custom.Done-Event"
#$WatchDogDoneSignal  = New-Object System.Threading.AutoResetEvent -ArgumentList $false
#$WatchDogDoneFlag    = 1

Function Remove-AppResources
{
    Write-Host "`nResetting Script Resources"

    if ($WatchDogTimer)
    {
        Write-Host "Removing WatchDogTimer"
        $WatchDogTimer.Dispose()
    }

    if ($WatchDogDoneSignal)
    {
        Write-Host "Removing Done-AutoResetEvent"
        $WatchDogDoneSignal.Dispose()
    }

    $OldSubscription = Get-EventSubscriber -SourceIdentifier $WatchDogTimerEventId -ErrorAction Ignore
    if ($OldSubscription)
    {
        Write-Host "UnRegistering Event Subscribers"
        ($OldSubscription | Format-List | Out-String).Trim() | Write-Verbose
        Unregister-Event -SourceIdentifier $WatchDogTimerEventId
    }

    # Remove Events in the Event Queue
    $OldEventS = Get-Event -ErrorAction Ignore
    if ($OldEventS)
    {
        Write-Host "Removing Events in Queue:" -NoNewline
        ($OldEventS | Format-Table | Out-String).Trim() | Write-Verbose
        $OldEvents | Remove-Event #-SourceIdentifier $WatchDogTimerEventId
    }
}
Remove-AppResources

$WatchDogTimer = New-Object System.Timers.Timer -Property @{
    Interval  = $WatchDogSec * 1000
    Autoreset = $True
}

# Script block to handle WatchdogTimer events
[ScriptBlock] $OnTimerElapsedAction = {
    <# Automatic Powrshell variables within a registered Action Script-Block:
    $Sender     = The object (Timer,Watcher...) that generated the event 
    $EventArgs  = The data associated with the event, generated by the Sender
    $Event      {
        ComputerName
        RunspaceId      = Unique [int]
        EventIdentifier = Unique [int]
        Sender          = $Sender
        SourceEventArgs = $EventArgs
        SourceArgs[]    = @(Sender, $EventArgs)
        SourceIdentifier= Unique name for the event e.g: "SenderName.EventName"
        TimeGenerated   = [DateTime]
        MessageData     = Optional data associated with New-Event -or
                          Optional data associated with event subscription
    }
    #>

    # No thread-save locking is needed to modify $EventCount, since the timer events run on the main thread
    Write-Host "xxxx EventCount=$GEventCountStr" -ForegroundColor Green
    $EventCount++   # The ++ seems to make a local copy
    Write-Host "`nHandling elapsed event: $EventCount" -ForegroundColor Green

    $RunSpace = Get-Runspace
    $RuntimeInfo = @{
        ThreadId         = [System.Threading.Thread]::CurrentThread.ManagedThreadId
        HostRunspace     = $Host.Runspace.Id
        RunspaceId       = $RunSpace.Id
    }
    ($RuntimeInfo | Format-Table | Out-String).Trim() | Write-Host

    Write-Host "`$EventArgs:" -ForegroundColor Cyan
    $EventArgs | ConvertTo-Json | Write-Host

    Write-Host "`$Event:" -ForegroundColor Cyan
    $Event | ConvertTo-Json | Write-Host

    Write-Host "ThreadId: " -ForegroundColor Cyan -NoNewline
    Write-Host ([System.Threading.Thread]::CurrentThread.ManagedThreadId)

    Write-Host "xxxx Host=$($Host.Name) ID=$WatchDogDoneEventId Flag=$WatchDogDoneFlag" -ForegroundColor Green
    Write-Host "xxxx G_Int=$G_Int" -ForegroundColor Green
    Write-Host "xxxx G_Str=$G_Str" -ForegroundColor Green
    # Notify Main loop that the Event handler is done using one of the mechenisms below:
    $DoneMsg = "Finalizing elapsed event: $EventCount"
    if ($WatchDogDoneSignal)
    {
        Write-Host "$DoneMsg -> Setting Done-AutoResetEvent" -ForegroundColor Green
        $WatchDogDoneSignal.Set()
    }
    elseif ($WatchDogDoneEventId)
    {
        if ($Host.Name -eq "ConsoleHost")
        {
            <#
                Exuction after calling New-Event() depends on the Powershell Hosting envirornmant:
                When running from a Powershell Console, execution of commands stop, after New-Event(),
                But NOT when running within Vs-Code.
            #>
            Write-Host "$DoneMsg`nNot calling New-Event(Done) because of side effects within Powershell console." -ForegroundColor Magenta
        }
        else 
        {
            Write-Host "$DoneMsg -> Posting Custom-Done-Event" -ForegroundColor Green
            $MsgData = @{EventCount = $EventCount; TimeGenerated = $Event.TimeGenerated }
            New-Event -SourceIdentifier $WatchDogDoneEventId -Sender "WatchdogTimer.EventHandler" -MessageData $MsgData #-EventArguments
        }
    }
    elseif ($WatchDogDoneFlag)
    {
        Write-Host "$DoneMsg -> Setting Done-Flag" -ForegroundColor Green
        $null = [Threading.Interlocked]::CompareExchange([ref]$WatchDogDoneFlag, 2, 1)
    }
    else 
    {
        Write-Host $DoneMsg -ForegroundColor Green
    }

    # Kill the application
    if ($EventCount -ge 3)
    {
        <#
            # Terminate powershell Session
            # Method 1
            $R = Get-Runspace
            $R[0].CloseAsync()

            # Method 2
            [Environment]::FailFast("Just terminate already")

            # Method 3
            Exit #  <== Does not work in event handler

            # Method 4
            [Environment]::Exit(1)
        #>
    }
    
    # The exception is silently caught by the Action invoker
    #Throw "My Timeout Exception"
}


$RegisterParamS = @{
    InputObject      = $WatchDogTimer
    EventName        = 'Elapsed'    # Name of System.Timers.Timer.Elapsed Delegate
    SourceIdentifier = $WatchDogTimerEventId
    Action           = $OnTimerElapsedAction
}
$TimerJob = Register-ObjectEvent @RegisterParamS -MessageData @{ MyData = "Hello Timer"}
Write-Host "Registered WatchDogTimer Event Handler:"
$TimerJob | Format-Table
#EndRegion PsEvent


##################### Main #####################
Write-Host "Start Watch-Dog Timer Demo Script" -ForegroundColor Yellow
$RunSpace = Get-Runspace
$RuntimeInfo = @{
    ThreadId         = [System.Threading.Thread]::CurrentThread.ManagedThreadId
    HostRunspace     = $Host.Runspace.Id
    RunspaceId       = $RunSpace.Id
}
($RuntimeInfo | Format-Table | Out-String).Trim() | Write-Host

Write-Host "Main loop waiting for WatchDog events:" -NoNewline
$EndTime = (Get-Date).AddSeconds($TotalSec)
$WatchDogTimer.Enabled = $True
try
{
    do 
    {
        Write-Host "." -NoNewline

        if ($WatchDogDoneSignal)
        {
            if ($WatchDogDoneSignal.WaitOne($IntervalMiliSec))
            {
                Write-Host "Main loop received Done-AutoResetEvent:" -NoNewline
            }
        }
        else 
        {
            Start-Sleep -Milliseconds $IntervalMiliSec
        }

        if ($WatchDogDoneEventId)
        {
            $WatchDogTimerEvent = Wait-Event -SourceIdentifier $WatchDogDoneEventId -Timeout 0
            if ($WatchDogTimerEvent)
            {
                $WatchDogTimerEvent | Remove-Event
                Write-Host "Main loop received Custom-Done-Event:" -NoNewline
            }
        }
        
        if ($WatchDogDoneFlag)
        {
            if ([Threading.Interlocked]::CompareExchange([ref]$WatchDogDoneFlag, 1, 2) -eq 2)
            {
                Write-Host "Main loop noticed Done-Flag:" -NoNewline                
            }
        }

    } until ((Get-Date) -ge $EndTime)
}
catch
{
    Write-Host $_.Exception.Message
}

# Free Event Resources
Remove-AppResources

Write-Host "`nExiting Watch-Dog Timer Demo Script"
